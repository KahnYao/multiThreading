
## 一、断开链条

```
遍历该链条两次，因为要断开的是两个不相连的环，所以两个环之间断开的最少距离需大于1。

每次遍历到该链条的一环时，记下成本值，遍历两次，则把两次成本相加取总成本值。

每次的成本值存放一临时变量，每遍历到一成本时和临时变量比大小，如小则用总本值替换出临时变量中的值。

最后输出的是最低成本。
```

## 二、从N个无序数中选取M个最大的数

```
首先从N个无序数列中取出M个数组成一数列M。

对数列M进行排序,把最小值放在首位，每次更新后都需重新把最小值放到首位。

从N的数列中从M位开始遍历到N数列的最后一位，把每一位数和M数列中的首位比较，大的替换M数列的首位，重新排序，然后排序M数列，如此循环。

最后得出的M数列即是N无序数列中最大的M个数。

```


## 三、最大方形

```
从矩阵中求出最大方形。

从(0，0)坐标出发，从左向右扫描，当值为0时停止，记录L值。

在从上向下扫描，扫到值为0时停止，记录L1值，比较min(L,L1)值，得到最小值。

得到最小的L时在回到原点(0,0)递归扫描，如扫到该值全为1时，则L为最大方形的边长。

否则一直递归扫描到坐标为(0,1) (1,0) (1,1)值为0时停止。输出L为0。
```

## 四、顺时针环绕列印矩阵元素
```
环绕矩阵打印，设一变量数组，数组大小为矩阵的元素个数。

顺时针环绕即是从该矩阵从左到右，在从上到下，从右向左，从下到上这个过程重复循环过程，

在循环过程中，记录下元素值存放到变量数组中。

打印数组即可得到顺时针矩阵元素。
```

## 五、问答题

### 1、假设手机掉到K层，出现两种情况，一种是碎了。一种是未碎。

    a;碎了，那么临界值在120〜K层之间的某一层，具体在哪一层，只能通过另一部手机一层一层尝试，这种尝试方法最坏的(120-K-1)次。这里总共尝试的次数

    是(120-K)次。

    b;未碎，尝试了1次，完了还得重新回头重来。有点类似于递归调用。直到K等于0。


综上a,b所述，假设

如只有一部手机，每个楼层深试一次，哪个楼层摔坏，哪一楼层算临界值，最坏情况是尝试120次。

119层摔坏了     最坏尝试次数1次
……             ……
110层摔坏了     最坏尝试次数10次(结束)       110层未摔坏     1 + 递归（减一层109...108...0）
……             ……                        ……             ……
100层摔坏了     最坏尝试次数20次(结束)       100层未摔坏     1 + 递归（减一层99...98...0）

得出结论

k+(k-1)+(k-2)+(k-3)+……+3+2+1 >= 120

K=15

推导最坏的情况尝试15次可得出结论。


